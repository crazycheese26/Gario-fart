<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Super Kart Browser 8</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: #333; user-select: none; }
        #canvas-container { width: 100vw; height: 100vh; display: block; }
        
        /* UI Overlay */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        
        /* HUD */
        #hud { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: none; }
        .hud-element { position: absolute; color: white; text-shadow: 2px 2px 0 #000; font-weight: bold; font-style: italic; }
        #lap-counter { top: 20px; right: 20px; font-size: 32px; }
        #rank-display { bottom: 20px; left: 20px; font-size: 64px; }
        #item-box { top: 20px; left: 20px; width: 80px; height: 80px; background: rgba(0,0,0,0.5); border: 4px solid white; border-radius: 10px; display: flex; justify-content: center; align-items: center; font-size: 40px; }
        #speedometer { bottom: 20px; right: 20px; font-size: 24px; text-align: right; }
        #countdown { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 120px; color: #ffcc00; text-shadow: 4px 4px 0 #000; display: none; }

        /* Main Menu */
        #menu { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: linear-gradient(135deg, #ff0055, #0055ff); display: flex; flex-direction: column; justify-content: center; align-items: center; pointer-events: auto; z-index: 10; }
        h1 { font-size: 60px; color: white; text-shadow: 4px 4px 0px rgba(0,0,0,0.5); margin-bottom: 10px; font-style: italic; transform: skew(-10deg); }
        .btn { background: #fff; border: none; padding: 15px 40px; font-size: 24px; margin: 10px; border-radius: 30px; cursor: pointer; font-weight: bold; transform: skew(-10deg); transition: transform 0.2s, background 0.2s; box-shadow: 0 5px 0 #ccc; }
        .btn:hover { transform: skew(-10deg) scale(1.1); background: #ffcc00; }
        .btn:active { transform: skew(-10deg) scale(0.95); box-shadow: 0 2px 0 #ccc; translateY(3px); }
        
        /* Mobile Controls */
        #mobile-controls { display: none; pointer-events: auto; }
        .touch-btn { position: absolute; width: 80px; height: 80px; background: rgba(255,255,255,0.3); border-radius: 50%; border: 2px solid white; display: flex; justify-content: center; align-items: center; color: white; font-size: 24px; user-select: none; }
        .touch-btn:active { background: rgba(255,255,255,0.6); }
        #btn-accel { bottom: 40px; right: 40px; width: 90px; height: 90px; background: rgba(0,255,0,0.3); }
        #btn-brake { bottom: 20px; right: 140px; width: 60px; height: 60px; background: rgba(255,0,0,0.3); }
        #btn-left { bottom: 40px; left: 20px; }
        #btn-right { bottom: 40px; left: 120px; }
        #btn-item { bottom: 140px; right: 40px; width: 70px; height: 70px; background: rgba(255,255,0,0.3); }

        @media (max-width: 800px) {
            #mobile-controls { display: block; }
            h1 { font-size: 40px; }
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <div id="canvas-container"></div>

    <div id="ui-layer">
        <div id="menu">
            <h1>SUPER KART BROWSER 8</h1>
            <p style="color:white; font-size: 18px; margin-bottom: 30px;">Arrow Keys to Drive | Space to Drift/Jump | Shift to Shoot</p>
            <button class="btn" onclick="startGame(100)">100cc (Normal)</button>
            <button class="btn" onclick="startGame(150)">150cc (Fast)</button>
            <button class="btn" onclick="startGame(200)">200cc (Crazy)</button>
        </div>

        <div id="hud">
            <div id="lap-counter" class="hud-element">Lap 1/3</div>
            <div id="rank-display" class="hud-element">1st</div>
            <div id="item-box" class="hud-element"></div>
            <div id="speedometer" class="hud-element">0 km/h</div>
            <div id="countdown" class="hud-element">3</div>
        </div>

        <div id="mobile-controls">
            <div id="btn-left" class="touch-btn">â—€</div>
            <div id="btn-right" class="touch-btn">â–¶</div>
            <div id="btn-accel" class="touch-btn">A</div>
            <div id="btn-brake" class="touch-btn">B</div>
            <div id="btn-item" class="touch-btn">â˜…</div>
        </div>
    </div>

    <script>
        // --- Constants & Globals ---
        const TRACK_WIDTH = 25;
        const SEGMENTS = 400;
        let scene, camera, renderer;
        let karts = [];
        let playerKart;
        let trackMesh, trackCurve;
        let projectiles = [];
        let itemBoxes = [];
        let gameActive = false;
        let clock = new THREE.Clock();
        let ccMode = 150;
        
        // Input State
        const keys = { 
            ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false, 
            w: false, a: false, s: false, d: false,
            Space: false, Shift: false 
        };

        // --- Init Function ---
        function init() {
            const container = document.getElementById('canvas-container');

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);

            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 200, 1000);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(100, 200, 100);
            dirLight.castShadow = true;
            dirLight.shadow.camera.top = 200;
            dirLight.shadow.camera.bottom = -200;
            dirLight.shadow.camera.left = -200;
            dirLight.shadow.camera.right = 200;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            scene.add(dirLight);

            // Camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);

            // Listeners
            window.addEventListener('resize', onWindowResize, false);
            document.addEventListener('keydown', (e) => onKey(e, true));
            document.addEventListener('keyup', (e) => onKey(e, false));
            
            // Mobile Listeners
            setupTouchControls();

            // Skybox (Procedural)
            createSkybox();

            animate();
        }

        // --- Game Logic ---

        function startGame(cc) {
            ccMode = cc;
            document.getElementById('menu').style.display = 'none';
            document.getElementById('hud').style.display = 'block';

            // Reset Scene
            while(scene.children.length > 0){ 
                scene.remove(scene.children[0]); 
            }
            // Re-add lights
            scene.add(new THREE.AmbientLight(0xffffff, 0.6));
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(100, 200, 100);
            dirLight.castShadow = true;
            scene.add(dirLight);
            createSkybox();

            // Generate Track
            createTrack();

            // Create Karts
            karts = [];
            // Player
            playerKart = new Kart(trackCurve, 0, true, 0xff0000);
            karts.push(playerKart);
            
            // Bots
            const botColors = [0x00ff00, 0x0000ff, 0xffff00, 0xff00ff, 0x00ffff, 0xff8800];
            for(let i=0; i<6; i++) {
                // Stagger starting positions slightly
                karts.push(new Kart(trackCurve, -0.01 * (i+1), false, botColors[i]));
            }

            // Create Item Boxes
            itemBoxes = [];
            createItemBoxes();

            projectiles = [];
            
            // Start Sequence
            startCountdown();
        }

        function startCountdown() {
            const el = document.getElementById('countdown');
            el.style.display = 'block';
            let count = 3;
            el.innerText = count;
            
            const intv = setInterval(() => {
                count--;
                if(count > 0) {
                    el.innerText = count;
                } else if (count === 0) {
                    el.innerText = "GO!";
                    el.style.color = "#00ff00";
                    gameActive = true;
                    clock.start();
                } else {
                    el.style.display = 'none';
                    clearInterval(intv);
                }
            }, 1000);
        }

        // --- Track Generation ---

        function createTrack() {
            // Create a closed loop spline
            const points = [];
            const radius = 300;
            // Create a twisty figure-8-ish loop
            for (let i = 0; i < 10; i++) {
                const angle = (i / 10) * Math.PI * 2;
                const x = Math.cos(angle) * radius * (1 + Math.sin(angle*2)*0.3);
                const z = Math.sin(angle) * radius * (1 + Math.cos(angle)*0.2);
                const y = Math.sin(angle * 3) * 60 + Math.cos(angle*5)*30; // Height variation
                points.push(new THREE.Vector3(x, y, z));
            }
            trackCurve = new THREE.CatmullRomCurve3(points);
            trackCurve.closed = true;
            trackCurve.tension = 0.5;

            // Geometry
            const tubeGeo = new THREE.TubeGeometry(trackCurve, SEGMENTS, TRACK_WIDTH/2, 8, true);
            
            // Texture
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            // Rainbow Road Style Gradient
            const grad = ctx.createLinearGradient(0,0,512,512);
            grad.addColorStop(0, '#ff0000');
            grad.addColorStop(0.2, '#ffff00');
            grad.addColorStop(0.4, '#00ff00');
            grad.addColorStop(0.6, '#00ffff');
            grad.addColorStop(0.8, '#0000ff');
            grad.addColorStop(1, '#ff00ff');
            ctx.fillStyle = grad;
            ctx.fillRect(0,0,512,512);

            // Checkerboard overlay
            ctx.fillStyle = "rgba(255,255,255,0.2)";
            for(let y=0; y<8; y++) {
                for(let x=0; x<8; x++) {
                    if((x+y)%2===0) ctx.fillRect(x*64, y*64, 64, 64);
                }
            }

            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = THREE.RepeatWrapping;
            tex.wrapT = THREE.RepeatWrapping;
            tex.repeat.set(40, 1);

            const mat = new THREE.MeshPhongMaterial({ 
                map: tex, 
                side: THREE.DoubleSide,
                shininess: 100
            });
            trackMesh = new THREE.Mesh(tubeGeo, mat);
            trackMesh.receiveShadow = true;
            scene.add(trackMesh);

            // Add simple rails needed? Nah, falling off is fun.
        }

        function createItemBoxes() {
            const boxGeo = new THREE.BoxGeometry(3,3,3);
            const boxMat = new THREE.MeshBasicMaterial({ color: 0xffff00, opacity: 0.8, transparent: true }); // Simple yellow box
            
            // Place boxes along the track
            for(let i=0; i<15; i++) {
                const t = (i / 15 + 0.05) % 1; // Evenly distributed
                const pos = trackCurve.getPointAt(t);
                const tangent = trackCurve.getTangentAt(t).normalize();
                const normal = new THREE.Vector3(0,1,0).applyAxisAngle(tangent, 0); // Approx Up
                const binormal = new THREE.Vector3().crossVectors(tangent, normal).normalize();

                // Create a row of 3 boxes
                for(let j=-1; j<=1; j++) {
                    const offset = binormal.clone().multiplyScalar(j * 8);
                    const boxPos = pos.clone().add(offset).add(new THREE.Vector3(0, 2, 0));
                    
                    const mesh = new THREE.Mesh(boxGeo, boxMat);
                    mesh.position.copy(boxPos);
                    mesh.userData = { active: true, respawnTimer: 0 };
                    scene.add(mesh);
                    itemBoxes.push(mesh);
                }
            }
        }

        // --- Kart Class ---

        class Kart {
            constructor(path, startT, isPlayer, color) {
                this.isPlayer = isPlayer;
                this.path = path;
                this.t = startT; // Position on curve (0-1)
                if (this.t < 0) this.t += 1;
                
                this.speed = 0;
                this.maxSpeed = isPlayer ? (ccMode * 0.8) : (ccMode * (0.75 + Math.random()*0.05)); // Bots slightly slower
                this.accel = ccMode * 0.5;
                this.turnSpeed = 1.5;
                this.driftFactor = 0;
                this.drifting = false;
                this.offset = 0; // Left/Right from center
                this.lap = 1;
                this.lastT = startT;
                this.item = null;
                this.boostTimer = 0;
                this.spinTimer = 0;
                
                // Visuals
                this.mesh = new THREE.Group();
                
                // Chassis
                const bodyGeo = new THREE.BoxGeometry(2.5, 1, 4);
                const bodyMat = new THREE.MeshPhongMaterial({ color: color });
                const body = new THREE.Mesh(bodyGeo, bodyMat);
                body.position.y = 1;
                body.castShadow = true;
                this.mesh.add(body);
                
                // Wheels
                const wheelGeo = new THREE.CylinderGeometry(0.8, 0.8, 0.8, 16);
                const wheelMat = new THREE.MeshLambertMaterial({ color: 0x333333 });
                wheelGeo.rotateZ(Math.PI/2);
                
                const fl = new THREE.Mesh(wheelGeo, wheelMat); fl.position.set(1.5, 0.8, 1.5);
                const fr = new THREE.Mesh(wheelGeo, wheelMat); fr.position.set(-1.5, 0.8, 1.5);
                const bl = new THREE.Mesh(wheelGeo, wheelMat); bl.position.set(1.5, 0.8, -1.5);
                const br = new THREE.Mesh(wheelGeo, wheelMat); br.position.set(-1.5, 0.8, -1.5);
                this.mesh.add(fl, fr, bl, br);
                
                // Head
                const headGeo = new THREE.SphereGeometry(0.8, 16, 16);
                const headMat = new THREE.MeshLambertMaterial({ color: 0xffccaa });
                const head = new THREE.Mesh(headGeo, headMat);
                head.position.set(0, 2.2, -0.5);
                this.mesh.add(head);

                scene.add(this.mesh);
            }

            update(dt) {
                if (this.spinTimer > 0) {
                    this.spinTimer -= dt;
                    this.mesh.rotation.y += 15 * dt;
                    this.speed *= 0.95;
                    // Keep moving along path slowly
                } else {
                    this.handlePhysics(dt);
                }
                
                this.updatePosition();
                
                // Bot Logic
                if (!this.isPlayer) this.botAI(dt);
            }

            handlePhysics(dt) {
                let throttle = 0;
                let turn = 0;
                let drift = false;
                let fire = false;

                if (this.isPlayer) {
                    if (keys.ArrowUp || keys.w) throttle = 1;
                    if (keys.ArrowDown || keys.s) throttle = -0.5;
                    
                    // Fixed reversed controls: Left decreases offset, Right increases offset
                    if (keys.ArrowLeft || keys.a) turn = -1;
                    if (keys.ArrowRight || keys.d) turn = 1;
                    
                    if (keys.Space) drift = true;
                    if (keys.Shift) fire = true;

                    // Mobile inputs
                    if (touchControls.accel) throttle = 1;
                    if (touchControls.brake) throttle = -1;
                    if (touchControls.left) turn = -1;
                    if (touchControls.right) turn = 1;
                    if (touchControls.item) fire = true;
                } else {
                    throttle = this.botThrottle;
                    turn = this.botTurn;
                    fire = this.botFire;
                }

                // Acceleration
                let topSpeed = this.maxSpeed;
                if (this.boostTimer > 0) {
                    topSpeed *= 1.5;
                    this.boostTimer -= dt;
                }

                if (throttle > 0) {
                    this.speed += this.accel * dt;
                } else if (throttle < 0) {
                    this.speed -= this.accel * dt;
                } else {
                    this.speed *= 0.98; // Friction
                }

                this.speed = Math.max(-20, Math.min(topSpeed, this.speed));

                // Turning
                if (Math.abs(this.speed) > 1) {
                    // Drifting logic
                    if (drift && !this.drifting && Math.abs(turn) > 0.1) {
                        this.drifting = true;
                        // Jump effect could go here
                    }
                    if (!keys.Space && !touchControls.accel /* Simplified drift exit */ ) {
                        this.drifting = false;
                    }

                    // tighter turn if drifting
                    let turnPower = this.turnSpeed;
                    if (this.drifting) turnPower *= 1.5;

                    // Apply turn to offset
                    this.offset += turn * turnPower * (this.speed / 100) * dt * 10;
                }

                // Limits
                if (this.offset > TRACK_WIDTH/2) { this.speed *= 0.9; this.offset = TRACK_WIDTH/2; }
                if (this.offset < -TRACK_WIDTH/2) { this.speed *= 0.9; this.offset = -TRACK_WIDTH/2; }

                // Move along spline
                // Convert speed (units/sec) to t (0-1)
                // Approx length of loop
                const trackLength = this.path.getLength();
                const tStep = (this.speed * dt) / trackLength;
                
                this.t += tStep;
                
                // Lap Counting
                if (this.t >= 1) {
                    this.t -= 1;
                    this.lap++;
                } else if (this.t < 0) {
                    this.t += 1;
                    this.lap--;
                }

                // Item usage
                if (fire && this.item) {
                    useItem(this);
                }

                // Check Item Box Collision
                checkItemBoxCollision(this);
            }

            updatePosition() {
                // Get point and rotation from curve
                const pos = this.path.getPointAt(this.t);
                const tangent = this.path.getTangentAt(this.t).normalize();
                const up = new THREE.Vector3(0, 1, 0); // Simplified up vector logic to prevent flipping
                
                // Calculate binormal for offset
                const binormal = new THREE.Vector3().crossVectors(tangent, up).normalize();
                
                // Apply Offset
                const actualPos = pos.clone().add(binormal.clone().multiplyScalar(this.offset));
                
                // LookAt logic
                const lookTarget = this.path.getPointAt((this.t + 0.01) % 1).add(binormal.clone().multiplyScalar(this.offset));

                this.mesh.position.copy(actualPos);
                this.mesh.lookAt(lookTarget);
                
                // Visual drift rotation
                if(this.drifting) {
                    // Slight visual tilt
                }

                // Camera follow player
                if (this.isPlayer) {
                    const camOffset = tangent.clone().multiplyScalar(-20).add(new THREE.Vector3(0, 10, 0));
                    camera.position.lerp(actualPos.clone().add(camOffset), 0.1);
                    camera.lookAt(actualPos);
                }
            }

            botAI(dt) {
                this.botThrottle = 1;
                // Simple steering to stay in center + noise
                // Target offset changes slowly
                if (!this.targetOffset || Math.random() < 0.01) {
                    this.targetOffset = (Math.random() - 0.5) * (TRACK_WIDTH * 0.8);
                }

                if (this.offset < this.targetOffset - 1) this.botTurn = 1;
                else if (this.offset > this.targetOffset + 1) this.botTurn = -1;
                else this.botTurn = 0;

                // Fire item if has one
                if (this.item && Math.random() < 0.01) {
                    this.botFire = true;
                } else {
                    this.botFire = false;
                }
            }
        }

        // --- Items & Projectiles ---

        function checkItemBoxCollision(kart) {
            if (kart.item) return; // Already has item

            const kartBox = new THREE.Box3().setFromObject(kart.mesh);

            for (let box of itemBoxes) {
                if (box.userData.active) {
                    const itemBox = new THREE.Box3().setFromObject(box);
                    if (kartBox.intersectsBox(itemBox)) {
                        // Pickup
                        box.visible = false;
                        box.userData.active = false;
                        box.userData.respawnTimer = 5; // 5 seconds respawn
                        
                        giveItem(kart);
                    }
                }
            }
        }

        function giveItem(kart) {
            const items = ["MUSHROOM", "SHELL"];
            const type = items[Math.floor(Math.random() * items.length)];
            kart.item = type;
            
            if (kart.isPlayer) {
                const hudBox = document.getElementById('item-box');
                hudBox.innerText = type === "MUSHROOM" ? "ðŸ„" : "ðŸ¢";
                hudBox.style.background = "rgba(255,200,0,0.5)";
            }
        }

        function useItem(kart) {
            if (kart.item === "MUSHROOM") {
                kart.boostTimer = 2; // 2 seconds boost
            } else if (kart.item === "SHELL") {
                // Shoot shell forward
                const shell = {
                    mesh: new THREE.Mesh(
                        new THREE.SphereGeometry(1,8,8), 
                        new THREE.MeshBasicMaterial({color: 0x00ff00})
                    ),
                    t: kart.t,
                    offset: kart.offset,
                    speed: 200, // faster than karts
                    owner: kart,
                    life: 5
                };
                
                // Initial position
                const pos = trackCurve.getPointAt(kart.t);
                shell.mesh.position.copy(pos);
                scene.add(shell.mesh);
                projectiles.push(shell);
            }

            kart.item = null;
            if (kart.isPlayer) {
                document.getElementById('item-box').innerText = "";
                document.getElementById('item-box').style.background = "rgba(0,0,0,0.5)";
            }
        }

        function updateProjectiles(dt) {
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i];
                p.life -= dt;
                
                // Move logic similar to karts but simpler
                const trackLength = trackCurve.getLength();
                const tStep = (p.speed * dt) / trackLength;
                p.t += tStep;
                if (p.t > 1) p.t -= 1;

                // Position visual
                const pos = trackCurve.getPointAt(p.t);
                const tangent = trackCurve.getTangentAt(p.t).normalize();
                const up = new THREE.Vector3(0, 1, 0);
                const binormal = new THREE.Vector3().crossVectors(tangent, up).normalize();
                const actualPos = pos.clone().add(binormal.multiplyScalar(p.offset));
                p.mesh.position.copy(actualPos);

                // Collision with karts
                for (let k of karts) {
                    if (k === p.owner) continue;
                    
                    // Simple distance check (approx collision)
                    const dist = k.mesh.position.distanceTo(p.mesh.position);
                    if (dist < 3) {
                        // Hit!
                        k.spinTimer = 1.5;
                        k.speed = 0;
                        
                        scene.remove(p.mesh);
                        projectiles.splice(i, 1);
                        break;
                    }
                }

                if (p.life <= 0) {
                    scene.remove(p.mesh);
                    projectiles.splice(i, 1);
                }
            }

            // Respawn Item Boxes
            for (let box of itemBoxes) {
                if (!box.userData.active) {
                    box.userData.respawnTimer -= dt;
                    if (box.userData.respawnTimer <= 0) {
                        box.userData.active = true;
                        box.visible = true;
                    }
                } else {
                    box.rotation.y += dt;
                    box.rotation.x += dt;
                }
            }
        }

        // --- Core Loops ---

        function updateHUD() {
            if(!playerKart) return;
            document.getElementById('speedometer').innerText = Math.floor(playerKart.speed * 2) + " km/h";
            document.getElementById('lap-counter').innerText = `Lap ${Math.min(playerKart.lap, 3)}/3`;
            
            // Calculate Rank
            // Sort karts by total distance traveled (lap + t)
            const sorted = [...karts].sort((a,b) => (b.lap + b.t) - (a.lap + a.t));
            const rank = sorted.indexOf(playerKart) + 1;
            let suffix = "th";
            if(rank === 1) suffix = "st";
            else if(rank === 2) suffix = "nd";
            else if(rank === 3) suffix = "rd";
            
            document.getElementById('rank-display').innerText = rank + suffix;

            if (playerKart.lap > 3) {
                gameActive = false;
                document.getElementById('countdown').style.display = 'block';
                document.getElementById('countdown').innerText = rank === 1 ? "WINNER!" : "FINISHED!";
                document.getElementById('countdown').style.color = rank === 1 ? "#gold" : "white";
                setTimeout(() => {
                    document.getElementById('menu').style.display = 'flex';
                    document.getElementById('hud').style.display = 'none';
                }, 3000);
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            
            const dt = clock.getDelta();

            if (gameActive) {
                // Update Karts
                karts.forEach(k => k.update(dt));
                updateProjectiles(dt);
                updateHUD();
            }

            renderer.render(scene, camera);
        }

        // --- Utils ---

        function createSkybox() {
            // Simple gradient sky sphere
            const canvas = document.createElement('canvas');
            canvas.width = 512; 
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createLinearGradient(0,0,0,512);
            grad.addColorStop(0, "#0044aa");
            grad.addColorStop(1, "#87CEEB");
            ctx.fillStyle = grad;
            ctx.fillRect(0,0,512,512);
            
            // Add clouds
            ctx.fillStyle = "rgba(255,255,255,0.4)";
            for(let i=0; i<20; i++) {
                ctx.beginPath();
                ctx.arc(Math.random()*512, Math.random()*256, Math.random()*40+20, 0, Math.PI*2);
                ctx.fill();
            }

            const tex = new THREE.CanvasTexture(canvas);
            const sph = new THREE.Mesh(
                new THREE.SphereGeometry(1000, 32, 32),
                new THREE.MeshBasicMaterial({ map: tex, side: THREE.BackSide, fog: false })
            );
            scene.add(sph);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onKey(event, pressed) {
            // Prevent default scrolling for game keys
            const key = event.key.toLowerCase();
            if(["arrowup","arrowdown","arrowleft","arrowright", " ", "w", "a", "s", "d"].indexOf(key) > -1) {
                // event.preventDefault(); // Optional: prevent scrolling
            }
            
            if (event.key === "ArrowUp") keys.ArrowUp = pressed;
            if (event.key === "ArrowDown") keys.ArrowDown = pressed;
            if (event.key === "ArrowLeft") keys.ArrowLeft = pressed;
            if (event.key === "ArrowRight") keys.ArrowRight = pressed;
            
            if (key === "w") keys.w = pressed;
            if (key === "a") keys.a = pressed;
            if (key === "s") keys.s = pressed;
            if (key === "d") keys.d = pressed;
            
            if (event.key === " ") keys.Space = pressed;
            if (event.key === "Shift") keys.Shift = pressed;
        }

        // Mobile Touch Logic
        const touchControls = { accel: false, brake: false, left: false, right: false, item: false };
        function setupTouchControls() {
            const bindBtn = (id, key) => {
                const el = document.getElementById(id);
                el.addEventListener('touchstart', (e) => { e.preventDefault(); touchControls[key] = true; });
                el.addEventListener('touchend', (e) => { e.preventDefault(); touchControls[key] = false; });
            };
            bindBtn('btn-accel', 'accel');
            bindBtn('btn-brake', 'brake');
            bindBtn('btn-left', 'left');
            bindBtn('btn-right', 'right');
            bindBtn('btn-item', 'item');
        }

        // Start init
        init();

    </script>
</body>
</html>
